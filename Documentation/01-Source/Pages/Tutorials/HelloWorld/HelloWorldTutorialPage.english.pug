extends ../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../SharedAssets/Markup/Assets.english.pug
  include ../../../Components/Components.english.pug


block append Metadata

  -

    HTML_PAGE_LANGUAGE = "en";
    HTML_PAGE_TITLE = buildHTML_PageTitle("Hello, world!");
    HTML_PageMetaData = {
      description: "The 'Hello, world!' tutorial for the Yamato-Daiwa Backend, the TypeScript and Node.js framework.",
      author: HTML_PAGE_AUTHOR
    }

    FAVICON_URI = "@MustBeInPublicRoot/favicon"

    styleSheetsURIs = [ "@Shared/CommonStyles", "@Layouts/TwoColumns/TwoColumnsLayout", "@Shared/ExternalComponents" ];
    scriptsURIs.endOfBody = [ "@Common" ];


block append SpecificContent

  article

    h1.Article-Heading1 "Hello, world!" - The simplest example

    h2.Article-Heading2 Pre-requirement knowledge and skills

    p.Article-Paragraph.
      It is implied that you are already can:

    ul.Article-OrderedList

      li.
        Create the #[+ImportantEntity--YDID Node.js] project and install #[+Term--YDID dependencies]
          (if no, you should to learn the #[+ImportantEntity--YDID Node.js] #[+Keyword--YDID fundamentals] first).

      li.
        Configure the #[+ImportantEntity--YDID TypeScript] compiler
          (#[+ImportantEntity--YDID @yamato-daiwa/backend] is intended to be used with
          #[+ImportantEntity__Code--YDID TypeScript], herewith without #[+ImportantEntity__Code--YDID any] type).

      li.
        Understand the #[+Term--YDID Object Orienting Programming] (#[+Term--YDID OOP]) fundamentals
          (the suggested #[+ImportantEntity--YDID @yamato-daiwa/backend] architecture is #[+Term--YDID OOP]-based).


    h2.Article-Heading2 Project initialization

    p.Article-Paragraph.
      Create the new Node.js project and install the following #[+Term--YDID dependencies].
      #[+Keyphrase--YDID During this lesson] it is strongly recommended to install the versions specified inside the
        square brackets to avoid the troubles caused by changing API with new versions of the #[+Term--YDID dependencies].

    dl.Article-DescriptionList

      dt @yamato-daiwa/backend [0.2.0]
      dd The main packages of this framework

      dt @yamato-daiwa/es-extensions [1.6.9]
      dd.
        Auxiliaries actual for both #[+ImportantEntity--YDID Node.js] and #[+ImportantEntity--YDID Browser JavaScript].
        For this tutorial, we will need only #[+ImportantEntity--YDID HTTP_Methods] #[+Term--YDID enumeration] from this
          package, but much more in the future.

      dt ts-node [10.9.1]
      dd.
        The #[+Link--YDF({ unendorsedExternalURI: "https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" }).Article-Link REPL]
          for the #[+ImportantEntity--YDID TypeScript].
        Creating the effect such that #[+ImportantEntity--YDID TypeScript] has own #[+Term--YDID runtime],
          thanks to what it will not spend our time to routines with output JavaScript files.

      dt typescript [5.0.4]
      dd.
        Them main package of the #[+ImportantEntity--YDID TypeScript] language.
        #[+ImportantEntity__Code--YDID ts-node] requires this package been installed manually.

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        npm i @yamato-daiwa/backend@0.2.0 @yamato-daiwa/es-extensions@1.6.9 -E

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        npm i ts-node@10.9.1 typescript@5.0.4 -D -E


    h2.Article-Heading2 Code

    p.Article-Paragraph.
      Bellow server application will return the text #[+ImportantEntity__Code--YDID "Hello, world!"] wrapped by
        #[+Term--YDID HTML tag] #[+ImportantEntity__Code--YDID h1] on #[+Term--YDID GET-type]
        #[+Term__Contrast--YDID HTTP request] by #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/] address.
      Before submit this request, let us analyze the source code of this simplest example.

    +CodeViewer--YDF

      +CodeViewer-TabPanel--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript,
        fileLabel: "Source code"
      })

        +CodeViewer-PartialListing--YDF.

          import { Server, Request, Response, ProtocolDependentDefaultPorts } from "@yamato-daiwa/backend";
          import { HTTP_Methods } from "@yamato-daiwa/es-extensions";


          Server.initializeAndStart({
        +CodeViewer-Explanation--YDF: p.Article-Paragraph.
          The #[+Term--YDID static method] #[+SecondaryEntity__Code--YDID initializeAndStart] of
            #[+SecondaryEntity__Code--YDID Server] #[+Term--YDID class] accepts the #[+Term--YDID configuration object]
            as first and only parameter.
          This method does things exactly according to its name, and only that's how it should be.

        +CodeViewer-PartialListing--YDF.
          &nbsp;&nbsp;IP_Address: "127.0.0.1",
        +CodeViewer-Explanation--YDF: p.Article-Paragraph.
          The #[+ImportantEntity__Code--YDID IP_Address] has been made to #[+Keyword--YDID required] property because
            you as engineer #[+Keyword--YDID must] comprehend on which #[+Term--YDID IP address] your server server
            application will run.
          In the real project, it will be #[+Keyword--YDID environment-dependent] (local, staging, production, etc.).
          We will discuss the conditional configuration in dedicated tutorials.
          For now, let the value #[+SecondaryEntity--YDID 127.0.0.1] AKA
            #[+Link--YDF({ unendorsedExternalURI: "https://en.wikipedia.org/wiki/Localhost" }).Article-Link the localhost].

        +CodeViewer-PartialListing--YDF.
          &nbsp;&nbsp;HTTP: { port: ProtocolDependentDefaultPorts.HTTP },
        +CodeViewer-Explanation--YDF: p.Article-Paragraph.
          The #[+ImportantEntity--YDID 80] - the value of #[+ImportantEntity__Code--YDID ProtocolDependentDefaultPorts.HTTP] -
            is the #[+Keyword--YDID default] #[+Term--YDID port] for #[+Term__Contrast--YDID HTTP protocol] case.
          It must be specified explicitly by the same reason as #[+ImportantEntity__Code--YDID IP_Address], however
            because rely to human's memory could be #[+Keyword--YDID dangerous], the default ports of various protocols
            has been stored to #[+ImportantEntity__Code--YDID ProtocolDependentDefaultPorts] #[+Term--YDID enumeration].
          From you it is required only to comprehend on default port will be available the application or on some one else.


        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
          &nbsp;&nbsp;routing: [
              {
                route: { HTTP_Method: HTTP_Methods.get, pathTemplate: "/" },
        +CodeViewer-Explanation--YDF: p.Article-Paragraph.
          The #[+ImportantEntity__Code--YDID routing], obviously and must be obviously for high quality naming,
            allows to define the #[+DefinableTerm--YDID роутинг] -
            #[+Keyphrase--YDID in the #[+Term--YDID server web development] context], the generating of various responses
            depending on accordance of request to specifis templates of #[+Term--YDID URI/URL].
          For this lesson, it is important what we are serving the #[+Keyword--YDID root] #[+Term--YDID route] only
            (corresponding to #[+Term--YDID URI] #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/]).
          For all other #[+Term--YDID routes], for example #[+SecondaryEntity__Code--YDID /foo] (corresponding to
            #[+Term--YDID URI] #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/foo]) or
            #[+SecondaryEntity__Code--YDID /bar/baz] (corresponding to #[+Term--YDID URI]
            #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/bar/baz]), the server will respond with "not found" error.

        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async handler(request: Request, response: Response): Promise＜void＞ {
        +CodeViewer-Explanation--YDF

          p.Article-Paragraph.
            The #[+DefinableTerm--YDID request handler] defines which actions must be executes when the submitted
              request satisfying to the #[+Term--YDID route] specified above in #[+ImportantEntity__Code--YDID route].
            This #[+Term--YDID function] is #[+Keyword--YDID a-priori] #[+Term--YDID asynchronous] (in the context of
              #[+ImportantEntity--YDID ECMAScript] it means the it must either explicitly or implicitly return the
              #[+ImportantEntity__Code--YDID Promise] instance) because the response submitting is #[+Term--YDID asynchronous].
            In addition the #[+Term--YDID request handler] frequently includes other asynchronous operations such as
              #[+Term--YDID database transactions] or files reading/writing.

          p.Article-Paragraph.
            In fact, the #[+ImportantEntity__Code--YDID route] and #[+ImportantEntity__Code--YDID handler] are like
              #[+Term--YDID conditional expression] and the action which must be executed when the
              #[+Term--YDID conditional expression] is truthy.

          p.Article-Paragraph.
            Usually the response is being generated depending on the request, which instance represented by
              #[+Keyword--YDID first] #[+Term--YDID parameter].
            For example, in the #[+Term--YDID GET-request] case we may need to access to #[+Term--YDID query parameters]
              (without #[+Term--YDID URI] context this term could be ambiguous), in the #[+Term--YDID POST-] or
              #[+Term--YDID PUT-request] case - to access the data containing in the #[+Term--YDID request body].
            However, we will postpone the manipulations with the instance of #[+ImportantEntity--YDID Response] class
              to subsequent, more difficult lessons; for now let us ignore the first parameter and always submit
              the same response.


        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return response.submitWithSuccess({ HTML_Content: "<h1>Hello, world!</h1>" });
        +CodeViewer-Explanation--YDF
          p.Article-Paragraph.
            As generally known, the #[+Term--YDID HTTP-response] has the status being abbreviated by 3-digits code.
            Currently it is important that these statuses are being split to #[+ImportantEntity--YDID 5] groups:

          ol.Article-OrderedList
            li Informational responses
            li Successful responses
            li Redirection messages
            li Client error responses
            li Server error responses

          p.Article-Paragraph.
            Method #[+ImportantEntity__Code--YDID submitWithSuccess] of the class #[+ImportantEntity__Code--YDID Response]
              submitting the code from the "successful" range (#[+ImportantEntity__Code--YDID 200] as default).
            Specifying the #[+ImportantEntity__Code--YDID HTML_Content] property of first and only #[+Term--YDID parameter]
              of #[+ImportantEntity__Code--YDID submitWithSuccess] #[+Term__Contrast--YDID method], we are expressing that
              going to submit the #[+Term--YDID HTML-код], and the framework will automatically set the necessary
              #[+Term--YDID HTTP-headers].
        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
                }
              }
            ]
          });


    h2.Article-Heading2 Тестирование

    p.Article-Paragraph.
      Let us launch our application by #[+ImportantEntity--YDID ts-node].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        ts-node EntryPoint.ts


    p.Article-Paragraph.
      If the code has not mistakes, you will be informed about application successful launching by the following
        terminal output:

    +SingleImageViewer--YDF({
      imageURI: "@AssociatedWithPages/Tutorials/HelloWorld/Images/ServerStartedSuccessLog",
      imageAlternateText: "The log about successful starting of HTTP-server generated by the framework " +
          "&quot;Yamato Daiwa Backend&quot; (abbreviation: &quot;YDB&quot;)",
      maximalWidth__anyValidCSS_Value: "400px"
    })


    p.Article-Paragraph.
      Open the displaying address in your browser.
      If your terminal can recognize the links, you can open it by mouse click.
      At least one log will be displayed, about request to #[+Term--YDID root route]:

    +SingleImageViewer--YDF({
      imageURI: "@AssociatedWithPages/Tutorials/HelloWorld/Images/RootRouteRequestInfoLog",
      imageAlternateText: "The log about request to root route generated by the framework " +
          "&quot;Yamato Daiwa Backend&quot; (abbreviation: &quot;YDB&quot;)",
    })


    p.Article-Paragraph.
      Probably one more request will be logged - about #[+ImportantEntity__Code--YDID /favicon.ico] #[+Term--YDID route]:

    +SingleImageViewer--YDF({
      imageURI: "@AssociatedWithPages/Tutorials/HelloWorld/Images/FaviconRequestInfoLog",
      imageAlternateText: "The log about requesting of the favicon, generated by the framework " +
          "&quot;Yamato Daiwa Backend&quot; (abbreviation: &quot;YDB&quot;)",
    })

    p.Article-Paragraph.
      If such log presents, it has been occurred by the browser #[+Keyword--YDID automatically] to display
      #[+Link--YDF({ unendorsedExternalURI: "https://en.wikipedia.org/wiki/Favicon" }).Article-Link the favicon].
      If the framework was not prepared to such request, it submitted the response with "not found" error
        however the #[+ImportantEntity--YDID YDB] #[+Term--YDID framework] submitting own icon #[+Keyword--YDID as default].
      Of course it could be replaced with another one, what we will do in one one of subsequent lessons.

    p.Article-Paragraph.
      The #[+ImportantEntity--YDID localhost] is the "pronoun" for the #[+Term--YDID IP-address]
        #[+ImportantEntity__Code--YDID 127.0.0.1], and #[+ImportantEntity--YDID 80] is the default #[+Term--YDID port]
        for the #[+Term--YDID HTTP], besides #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/] we can submit the requests
        to #[+SecondaryEntity__Code--YDID http://localhost], #[+SecondaryEntity__Code--YDID http://localhost:80] or
        #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/].

    p.Article-Paragraph.
      Finally, let us se how the framework will behave when we will submit the request which has not the matching
        in #[+ImportantEntity__Code--YDID routing].
      For example, for the request #[+SecondaryEntity__Code--YDID http://127.0.0.1:80/foo] the log will be:

    +SingleImageViewer--YDF({
      imageURI: "@AssociatedWithPages/Tutorials/HelloWorld/Images/ServerErrorLog",
      imageAlternateText: "The log about not found resource, generated by the framework " +
          "&quot;Yamato Daiwa Backend&quot; (abbreviation: &quot;YDB&quot;)",
    })

    p.Article-Paragraph.
      The frameworks logged that the requested resource not fond found.
      The browser should display the similar message basing on #[+Term--YDID response status]
        #[+ImportantEntity--YDID 404 Not found].
